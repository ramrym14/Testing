"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = exports.expect = void 0;
/* eslint-disable no-console */
const index_1 = require("../index");
const test_1 = require("@playwright/test");
const getEyes_1 = require("./getEyes");
var toHaveScreenshot_1 = require("./toHaveScreenshot");
Object.defineProperty(exports, "expect", { enumerable: true, get: function () { return toHaveScreenshot_1.expect; } });
const utils = __importStar(require("@applitools/utils"));
const reporter_1 = require("./reporter");
const url_1 = require("url");
exports.test = test_1.test.extend({
    eyesConfig: [{}, { option: true }],
    eyesRunner: [
        async ({}, use, workerInfo) => {
            var _a;
            const eyesConfig = await getEyesConfigForWorker(workerInfo);
            const runner = eyesConfig.type === 'ufg' ? new index_1.VisualGridRunner(eyesConfig) : new index_1.ClassicRunner(eyesConfig);
            await use(runner);
            if (runner.isUsed) {
                output(`Waiting on eyes results for worker #${workerInfo.parallelIndex}-${workerInfo.workerIndex} - it might take a while`);
            }
            try {
                await Promise.all((_a = runner === null || runner === void 0 ? void 0 : runner.fixturePromises) !== null && _a !== void 0 ? _a : []);
                await runner.getAllTestResults(eyesConfig.failTestsOnDiff === 'afterAll').catch(err => {
                    const newError = new Error(err.message);
                    newError.stack = undefined;
                    throw newError;
                });
            }
            finally {
                const results = await runner.getAllTestResults(false);
                if (runner.isUsed) {
                    output(outputDigest(workerInfo, results));
                }
                if (eyesConfig.afterAll) {
                    await eyesConfig.afterAll(results.getAllResults());
                }
            }
        },
        { scope: 'worker', timeout: 0 },
    ],
    page: async ({ page, eyesRunner, eyesConfig }, use) => {
        // save the configurations and settings for the `expect.toHaveScreenshot` override
        ;
        page.__eyesRunner = eyesRunner;
        page.__eyesConfig = eyesConfig; // TODO merge playwrightConfig, projectConfig, eyesConfig
        await use(page);
    },
    eyes: [
        async ({ page, eyesConfig, eyesRunner }, use, testInfo) => {
            const eyes = await (0, getEyes_1.getEyes)({
                testInfo,
                eyesConfig,
                eyesRunner,
                page,
            });
            await use(eyes);
        },
        { timeout: 0 },
    ],
    closeEyesIfNeeded: [
        async ({ page, eyesConfig, eyesRunner: runner }, use, testInfo) => {
            const isUsingEyesReporter = testInfo.config.reporter.some(r => r[0].includes('eyes-playwright'));
            if (isUsingEyesReporter) {
                const internalId = utils.general.guid();
                await testInfo.attach('internalId', { body: internalId });
            }
            await use();
            const eyes = page.__eyes;
            if (eyes) {
                await eyes.closeAsync();
                if (isUsingEyesReporter) {
                    writeResultsWhenReady({ eyes, runner, testInfo });
                }
                if (eyesConfig.failTestsOnDiff === 'afterEach') {
                    await eyes.getResults(true);
                }
            }
        },
        { timeout: 0, auto: true },
    ],
});
function outputDigest(workerInfo, results) {
    const batchUrls = [...new Set(results.getAllResults().map(r => r.testResults.appUrls.batch))];
    if (batchUrls.length === 0) {
        return 'No results found for Eyes';
    }
    else {
        return `Eyes results for worker #${workerInfo.parallelIndex}-${workerInfo.workerIndex}: ${batchUrls.length > 1 ? batchUrls.join('\n  ') : batchUrls[0]}`;
    }
}
function output(...args) {
    console.log('ðŸ‘€', ...args);
}
function writeResultsWhenReady({ eyes, runner, testInfo }) {
    var _a;
    const fixturePromises = ((_a = runner.fixturePromises) !== null && _a !== void 0 ? _a : (runner.fixturePromises = []));
    fixturePromises.push(eyes
        .getResults(false)
        .then(async (testResults) => {
        await reporter_1.InternalData.write({ testInfo, data: testResults });
    })
        .catch((e) => {
        var _a;
        // TODO error handling
        throw new Error(`Failed to get eyes test results: ${(_a = e === null || e === void 0 ? void 0 : e.message) !== null && _a !== void 0 ? _a : e} ${e === null || e === void 0 ? void 0 : e.stack}`);
    }));
}
async function getEyesConfigForWorker(workerInfo) {
    var _a, _b, _c;
    const { configFile } = workerInfo.config;
    const playwrightConfig = (_b = (_a = ((configFile ? await import((0, url_1.pathToFileURL)(configFile).href) : {}))) === null || _a === void 0 ? void 0 : _a.use) === null || _b === void 0 ? void 0 : _b.eyesConfig;
    const projectConfig = workerInfo.project.use.eyesConfig;
    const eyesConfig = {
        ...playwrightConfig,
        ...projectConfig,
    };
    (_c = eyesConfig.failTestsOnDiff) !== null && _c !== void 0 ? _c : (eyesConfig.failTestsOnDiff = process.env.CI ? 'afterAll' : 'afterEach');
    return eyesConfig;
}
